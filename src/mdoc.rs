use std::ops::{Add, AddAssign};

use crate::raw::Roff;

/// Mandoc document
#[derive(Debug, Clone)]
pub struct MDoc {
    roff: Roff,
}

impl AddAssign<&MDoc> for MDoc {
    fn add_assign(&mut self, rhs: &MDoc) {
        self.roff += &rhs.roff;
    }
}

impl Add<&MDoc> for MDoc {
    type Output = Self;
    fn add(mut self, rhs: &MDoc) -> Self {
        self.roff += &rhs.roff;
        self
    }
}

impl MDoc {
    ////////////////////////////////////////////////////////////////////////////
    // Document preamble and NAME section macros
    ////////////////////////////////////////////////////////////////////////////
    // Dd 	document date: $Mdocdate$ | month day, year
    // Dt 	document title: TITLE section [arch]
    // Os 	operating system version: [system [version]]
    // Nm 	document name (one argument)
    // Nd 	document description (one line)
    /// Create a mandoc document, write a preamble
    pub fn new(date: &str, title: &str, name: &str, description: &str) -> Self {
        let mut roff = Roff::default();
        roff.roff_comment("Generated by roff-rs")
            .control("Dd", [date])
            .control("Dt", [title])
            .control("Os", None::<&str>)
            .control("Nm", [name])
            .control("Nd", [description]);

        Self { roff }
    }

    /// Create a new mandoc document without a preamble
    ///
    /// Useful for monoidal concatenation
    pub fn blank() -> Self {
        Self {
            roff: Roff::default(),
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // Sections and cross references
    ////////////////////////////////////////////////////////////////////////////
    // Sx 	internal cross reference to a section or subsection
    // Xr 	cross reference to another manual page: name section
    // Tg 	tag the definition of a term (<= 1 arguments)
    // Pp 	start a text paragraph (no arguments)

    /// Section header
    pub fn section(&mut self, name: &str) -> &mut Self {
        self.roff.control("Sh", [name]);
        self
    }

    /// Subsection header
    pub fn subsection(&mut self, name: &str) -> &mut Self {
        self.roff.control("Ss", [name]);
        self
    }

    ////////////////////////////////////////////////////////////////////////////
    // Displays and lists
    ////////////////////////////////////////////////////////////////////////////
    // Bd, Ed 	display block: -type [-offset width] [-compact]
    // D1 	indented display (one line)
    // Dl 	indented literal display (one line)
    // Ql 	in-line literal display: ‘text’
    // Bl, El 	list block: -type [-width val] [-offset val] [-compact]
    // It 	list item (syntax depends on -type)
    // Ta 	table cell separator in Bl -column lists
    // Rs, %*, Re 	bibliographic block (references)

    ////////////////////////////////////////////////////////////////////////////
    // Spacing control
    ////////////////////////////////////////////////////////////////////////////
    // Pf 	prefix, no following horizontal space (one argument)
    // Ns 	roman font, no preceding horizontal space (no arguments)
    // Bk, Ek 	keep block: -words

    // Sm 	switch horizontal spacing mode: [on | off]
    pub fn set_horizontal_spacing(&mut self, state: bool) -> &mut Self {
        let mode = if state { "on" } else { "off" };
        self.roff.control("Sm", [mode]);
        self
    }

    // Ap 	apostrophe without surrounding whitespace (no arguments)
    pub fn apostrophe(&mut self) -> &mut Self {
        self.roff.control("Ap", None::<&str>);
        self
    }

    /// Insert the tool name
    pub fn name(&mut self) -> &mut Self {
        self.roff.control("Nm", None::<&str>);
        self
    }

    ////////////////////////////////////////////////////////////////////////////
    // Semantic markup for command line utilities
    ////////////////////////////////////////////////////////////////////////////

    /// Enclose in []
    pub fn optional<F>(&mut self, f: F) -> &mut Self
    where
        F: Fn(&mut MDoc),
    {
        self.roff.control("Oo", None::<&str>);
        f(self);
        self.roff.control("Oc", None::<&str>);
        self
    }

    /// Enclose in ()
    pub fn required<F>(&mut self, f: F) -> &mut Self
    where
        F: Fn(&mut MDoc),
    {
        self.roff.control("Po", None::<&str>);
        f(self);
        self.roff.control("Pc", None::<&str>);
        self
    }

    pub fn metavar(&mut self, name: &str) -> &mut Self {
        self.roff.control("Ar", [name]);
        self
    }

    pub fn short(&mut self, name: char) -> &mut Self {
        let mut buf = [0u8; 6];
        self.roff.control("Fl", [name.encode_utf8(&mut buf)]);
        self
    }

    pub fn long(&mut self, name: &str) -> &mut Self {
        self.roff.control("Fl", [format!("\\-{}", name)]);
        self
    }

    // Ev 	environmental variable (>0 arguments)
    pub fn env(&mut self, name: &str) -> &mut Self {
        self.roff.control("Ev", [name]);
        self
    }

    pub fn command<I, S>(&mut self, items: I) -> &mut Self
    where
        I: IntoIterator<Item = S>,
        S: AsRef<str>,
    {
        self.roff.control("Cm", items);
        self
    }

    // interactive command
    pub fn interative_command<I, S>(&mut self, items: I) -> &mut Self
    where
        I: IntoIterator<Item = S>,
        S: AsRef<str>,
    {
        self.roff.control("Ic", items);
        self
    }

    // Pa 	file system path (>=0 arguments)
    pub fn path(&mut self, name: &str) -> &mut Self {
        self.roff.control("Pa", [name]);
        self
    }

    ////////////////////////////////////////////////////////////////////////////
    // Semantic markup for function libraries
    ////////////////////////////////////////////////////////////////////////////
    // Lb 	function library (one argument)
    // In 	include file (one argument)
    // Fd 	other preprocessor directive (>0 arguments)
    // Ft 	function type (>0 arguments)
    // Fo, Fc 	function block: funcname
    // Fn 	function name: funcname [argument ...]
    // Fa 	function argument (>0 arguments)
    // Vt 	variable type (>0 arguments)
    // Va 	variable name (>0 arguments)
    // Dv 	defined variable or preprocessor constant (>0 arguments)
    // Er 	error constant (>0 arguments)
    // Ev 	environmental variable (>0 arguments)

    ////////////////////////////////////////////////////////////////////////////
    // Various semantic markup
    ////////////////////////////////////////////////////////////////////////////
    // An 	author name (>0 arguments)
    // Lk 	hyperlink: uri [display_name]
    // Mt 	“mailto” hyperlink: localpart@domain
    // Cd 	kernel configuration declaration (>0 arguments)
    // Ad 	memory address (>0 arguments)
    // Ms 	mathematical symbol (>0 arguments)

    ////////////////////////////////////////////////////////////////////////////
    // Physical markup
    ////////////////////////////////////////////////////////////////////////////
    // Em 	italic font or underline (emphasis) (>0 arguments)
    // Sy 	boldface font (symbolic) (>0 arguments)
    // No 	return to roman font (normal) (>0 arguments)
    // Bf, Ef 	font block: -type | Em | Li | Sy

    ////////////////////////////////////////////////////////////////////////////
    // Physical enclosures
    ////////////////////////////////////////////////////////////////////////////
    // Dq, Do, Dc 	enclose in typographic double quotes: “text”
    // Qq, Qo, Qc 	enclose in typewriter double quotes: "text"
    // Sq, So, Sc 	enclose in single quotes: ‘text’
    // Pq, Po, Pc 	enclose in parentheses: (text)
    // Bq, Bo, Bc 	enclose in square brackets: [text]
    // Brq, Bro, Brc 	enclose in curly braces: {text}
    // Aq, Ao, Ac 	enclose in angle brackets: ⟨text⟩
    // Eo, Ec 	generic enclosure

    ////////////////////////////////////////////////////////////////////////////
    // Text production
    ////////////////////////////////////////////////////////////////////////////
    // Ex -std 	standard command exit values: [utility ...]
    // Rv -std 	standard function return values: [function ...]
    // St 	reference to a standards document (one argument)
    // At 	AT&T UNIX
    // Bx 	BSD
    // Bsx 	BSD/OS
    // Nx 	NetBSD
    // Fx 	FreeBSD
    // Ox 	OpenBSD
    // Dx 	DragonFly

    pub fn render(&self) -> String {
        self.roff.render(crate::raw::Apostrophes::DontHandle)
    }
}

#[cfg(test)]
mod test {
    use crate::write_updated;

    use super::*;

    #[test]
    fn sample() {
        let mut doc = MDoc::new("date", "title", "name", "description");

        doc.name().interative_command(["Fl"]).required(|d| {
            d.long("long1").long("Fl").metavar("FILE");
        });

        let text = doc.render();
        write_updated(&text, "sample.1").unwrap();
    }
}
